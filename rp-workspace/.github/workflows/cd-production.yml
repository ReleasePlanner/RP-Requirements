name: CD - Production

on:
  push:
    tags:
      - 'v*.*.*'  # Triggered on version tags like v1.0.0
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., 1.0.0)'
        required: true
        type: string

env:
  NODE_VERSION: '20.x'
  PNPM_VERSION: '8'
  ENVIRONMENT: 'production'

jobs:
  integrity-verification:
    name: Pre-Deployment Integrity Check
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: requirements_db_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: |
          echo "üîç Running lint checks..."
          npm run lint:api || exit 1
          cd apps/portal && npm run lint || exit 1
          echo "‚úÖ Linting passed"

      - name: Run tests with coverage verification
        working-directory: apps/api
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: requirements_db_test
          DB_SYNCHRONIZE: true
          JWT_SECRET: test-jwt-secret-key-min-32-characters-long
          JWT_EXPIRES_IN: 1h
        run: |
          echo "üß™ Running tests with coverage check..."
          npm run test:cov:check || {
            echo "‚ùå Coverage threshold not met!"
            exit 1
          }
          echo "‚úÖ Tests and coverage passed"

      - name: Verify API build
        run: |
          echo "üèóÔ∏è Verifying API build..."
          npm run build:api || exit 1
          echo "‚úÖ API build successful"

      - name: Verify Portal build
        working-directory: apps/portal
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION || 'http://localhost:3000/api/v1' }}
        run: |
          echo "üèóÔ∏è Verifying Portal build..."
          npm run build || exit 1
          echo "‚úÖ Portal build successful"

      - name: Integrity check summary
        run: |
          echo "## ‚úÖ Pre-Deployment Integrity Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All checks passed - Application is ready for production deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Linting" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Tests & Coverage (100%)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ API Build" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Portal Build" >> $GITHUB_STEP_SUMMARY

  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    needs: [integrity-verification]
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Create release notes
        id: release-notes
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const version = '${{ steps.version.outputs.version }}';
            const tag = `v${version}`;
            
            // Generate changelog
            let changelog = `# Release ${tag}\n\n`;
            changelog += `## Changes\n\n`;
            
            try {
              const lastTag = execSync('git describe --tags --abbrev=0 HEAD^', { encoding: 'utf-8' }).trim();
              const commits = execSync(`git log ${lastTag}..HEAD --pretty=format:"- %s (%h)"`, { encoding: 'utf-8' });
              changelog += commits || '- Initial release\n';
            } catch (e) {
              changelog += '- Initial release\n';
            }
            
            fs.writeFileSync('docs/RELEASE_NOTES.md', changelog);
            
            return { changelog };

  deploy-api-production:
    name: Deploy API to Production
    runs-on: ubuntu-latest
    needs: [prepare-release]
    environment:
      name: production
      url: ${{ secrets.API_PRODUCTION_URL || 'https://api.example.com' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Build API
        run: npm run build:api

      - name: Run database migrations
        working-directory: apps/api
        env:
          NODE_ENV: production
          DB_HOST: ${{ secrets.DB_PRODUCTION_HOST }}
          DB_PORT: ${{ secrets.DB_PRODUCTION_PORT }}
          DB_USERNAME: ${{ secrets.DB_PRODUCTION_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PRODUCTION_PASSWORD }}
          DB_DATABASE: ${{ secrets.DB_PRODUCTION_DATABASE }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
        run: npm run migration:run || echo "Migrations already applied"

      - name: Build Docker image
        run: |
          docker build -f apps/api/Dockerfile -t ${{ secrets.DOCKER_REGISTRY }}/api:${{ needs.prepare-release.outputs.version }} .
          docker build -f apps/api/Dockerfile -t ${{ secrets.DOCKER_REGISTRY }}/api:latest .

      - name: Push Docker image
        if: success()
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login ${{ secrets.DOCKER_REGISTRY }} -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker push ${{ secrets.DOCKER_REGISTRY }}/api:${{ needs.prepare-release.outputs.version }}
          docker push ${{ secrets.DOCKER_REGISTRY }}/api:latest

      - name: Deploy to production
        run: |
          echo "Deploying API version ${{ needs.prepare-release.outputs.version }} to production..."
          # Agregar comandos de deployment espec√≠ficos aqu√≠
          # Ejemplo Kubernetes:
          # kubectl set image deployment/api-production api=${{ secrets.DOCKER_REGISTRY }}/api:${{ needs.prepare-release.outputs.version }} -n production
          # kubectl rollout status deployment/api-production -n production

      - name: Health check
        run: |
          echo "Waiting for API to be ready..."
          sleep 30
          # curl -f ${{ secrets.API_PRODUCTION_URL }}/api/health || exit 1

  deploy-portal-production:
    name: Deploy Portal to Production
    runs-on: ubuntu-latest
    needs: [prepare-release]
    environment:
      name: production
      url: ${{ secrets.PORTAL_PRODUCTION_URL || 'https://portal.example.com' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Build Portal
        working-directory: apps/portal
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION }}
        run: npm run build

      - name: Build Docker image
        run: |
          docker build -f apps/portal/Dockerfile --build-arg NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION }} -t ${{ secrets.DOCKER_REGISTRY }}/portal:${{ needs.prepare-release.outputs.version }} .
          docker build -f apps/portal/Dockerfile --build-arg NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL_PRODUCTION }} -t ${{ secrets.DOCKER_REGISTRY }}/portal:latest .

      - name: Push Docker image
        if: success()
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login ${{ secrets.DOCKER_REGISTRY }} -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker push ${{ secrets.DOCKER_REGISTRY }}/portal:${{ needs.prepare-release.outputs.version }}
          docker push ${{ secrets.DOCKER_REGISTRY }}/portal:latest

      - name: Deploy to production
        run: |
          echo "Deploying Portal version ${{ needs.prepare-release.outputs.version }} to production..."
          # Agregar comandos de deployment espec√≠ficos aqu√≠

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, deploy-api-production, deploy-portal-production]
    if: success()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.prepare-release.outputs.version }}
          release_name: Release v${{ needs.prepare-release.outputs.version }}
          body_path: docs/RELEASE_NOTES.md
          draft: false
          prerelease: false

  notify-production:
    name: Notify Production Deployment
    runs-on: ubuntu-latest
    needs: [deploy-api-production, deploy-portal-production, create-release]
    if: always()
    steps:
      - name: Send notification
        run: |
          if [ "${{ needs.deploy-api-production.result }}" == "success" ] && \
             [ "${{ needs.deploy-portal-production.result }}" == "success" ] && \
             [ "${{ needs.create-release.result }}" == "success" ]; then
            echo "‚úÖ Production deployment successful - Version ${{ needs.prepare-release.outputs.version }}"
            # Agregar notificaciones aqu√≠
          else
            echo "‚ùå Production deployment failed"
            exit 1
          fi

